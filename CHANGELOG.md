# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Planning]

### 管理器命名
從 xxxxan 改成 xxxxmgr

### 實體
核心組件, 包含實體編號, 名稱, 模組管理器, 事件管理器, 接收管理器, 傳送管理器
接收管理器分為單緒或是多緒, 如果是客戶端實體就用單緒, 伺服器實體就用多緒
* public 取得實體編號
* public 取得名稱
* public 新增模組
* public 刪除模組
* public 取得模組
* public 新增封包
* public 刪除封包
* public 執行封包
* public 傳送封包
* public 新增標籤
* public 刪除標籤
* private 初始化處理
* private 結束處理

### 實體編號
建立實體時的實體編號由外部決定
實體編號可能用會話編號代替(未確定)

### 實體管理器(獨立)
管理實體, 可以新增/刪除/搜尋實體
* public 新增實體
* public 刪除實體
* public 取得實體

### 模組
模組由核心與擴展組成
核心包含模組編號, 名稱, 宿主實體; 核心外觀必須符合模組介面
擴展則是提供給使用者自訂模組功能, 產生程式碼時需要避免把使用者定義好的擴展覆蓋掉
* public 取得模組編號
* public 取得名稱
* public 取得宿主實體
* public 設定宿主實體

### 模組編號
建立模組時的模組編號由外部決定

### 模組事件
當實體觸發系統事件時, 會把擁有的模組都拿出來執行一次系統事件
這些系統事件以介面方式觸發, 所以如果沒有實作介面就不會觸發系統事件(也不會錯誤)
* public awake
* public start
* public dispose
* public update

### 模組介面
模組管理器中儲存的不是模組本身, 而是模組介面
* public 取得模組編號
* public 取得名稱
* public 取得宿主實體
* public 設定宿主實體

### 模組管理器
管理模組, 可以新增/刪除/搜尋模組
搜尋模組用模組編號
* public 新增模組
* public 刪除模組
* public 取得模組

### 事件管理器
管理事件通道, 執行事件
依靠一個通道與事件處理函式來運作, 是單執行緒處理
* public 初始化處理(事件處理函式)
* public 結束處理
* public 執行awake事件
* public 執行start事件
* public 執行dispose事件
* public 執行update事件

### 接收管理器
管理封包接收, 註冊封包, 執行封包
分成兩種模式
- 單緒模式: 依靠通道與封包列表運作, 封包執行在另一個獨立運作的執行緒中
- 多緒模式: 依靠封包列表運作, 封包由呼叫者執行
* public 初始化處理(會話物件)
* public 結束處理
* public 新增封包
* public 刪除封包
* public 執行封包

### 傳送管理器
管理封包傳送
* public 初始化處理(會話物件)
* public 傳送封包

### 標籤管理器(獨立)
依靠標籤來分類, 搜尋實體列表
* public 新增標籤(標籤, 實體編號)
* public 刪除標籤(標籤, 實體編號)
* public 取得列表(標籤) []實體編號

### 網路管理器(獨立)
管理連接與接聽
連接完成時會新增會話物件
接聽時有連線完成時會新增會話物件
可以對多個port進行接聽
當新增/刪除會話物件時, 會執行外部指定的函式指標
可以用會話編號取得會話物件
* public 啟動網路(吃組網設定檔)
* public 啟動連接(新增會話處理函式, 刪除會話處理函式)
    * 新增會話處理函式: 負責新增實體, 組裝實體, 初始化實體
    * 刪除會話處理函式: 負責刪除實體, 結束實體
* public 啟動接聽(新增會話處理函式, 刪除會話處理函式)
    * 新增會話處理函式: 負責新增實體, 組裝實體, 初始化實體
    * 刪除會話處理函式: 負責刪除實體, 結束實體
* public 刪除會話
* public 取得會話
   
### 網路機制(獨立)
接聽/連接到遠端, 並產生會話物件來進行封包發送與接收處理
* 網路介面
    * 接聽(go)
    * 連接(go)
        * 只能連接一個服務端
    * 會話(go)
    * 客戶(go+cs)
        * 相當於連接組件與會話組件的組合, 專門給客戶端使用
        * 只能連接一個服務端
* tcp組件
    * 接聽(go)
    * 連接(go)
    * 會話(go)
    * 客戶(go+cs)
* udp組件
* http組件

### 封包機制(獨立)
封包如何組成, 有哪些欄位, 提供給網路機制用的管線物件
* 管線介面
    * 接收處理
    * 傳送處理
* proto管線
    * 接收處理: 移除標頭 > 解密 > 反序列化
    * 傳送處理: 序列化 > 加密 > 填寫標頭(封包長度)

### 加解密機制(獨立)
* ????加解密

### 日誌機制
提供接口讓內部的日誌可以輸出到使用者希望的組件上

### 如何組織網路
難點可能在設定檔如何安排, 尤其是如果只想用單一設定檔案來描述整個網路與伺服器該怎麼做
前次的做法是為伺服器定義群名稱, 然後可能會先安排群內互聯(不確定), 然後再安排群與群之間是否有連接關係
由於mizugo的連接會有連接與接聽方, 因此群與群之間的連接是否也該定義好誰為連接方, 誰為接聽方

### 資料庫機制
如何初始化資料庫組件, 操作資料庫
* redis
* mysql
* mongo
* 資料庫機制自動代碼產生的範圍
TODO: 資料庫機制還可以再細分

### 單元測試工具
規劃中

### 流程測試框架
規劃中

### 伺服器程式碼產生
等基礎的項目完成後才有辦法開始規劃吧
* 有哪些程式碼要產生
* 有哪些設定檔要產生
* 要產生在那些目錄(以及目錄結構)
* 要怎麼避免覆蓋掉使用者寫的程式碼
* 產生出的程式碼仍然要保持易讀性
